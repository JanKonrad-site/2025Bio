<!-- =========================================================
     4.1.8 MOST: Rozpočet krok za krokem
     (seznam n-tic → čisté funkce → VOLBY → DISPATCH → .get() → Undo)
     ========================================================= -->
<section id="section4-1-8-bridge-budget-mini" class="container my-5">
  <style>
    .tip{border-left:4px solid #0d6efd;background:#f8f9fa;padding:.75rem 1rem}
    .warn{border-left:4px solid #dc3545;background:#fff5f5;padding:.75rem 1rem}
    .ok{border-left:4px solid #198754;background:#f6fff8;padding:.75rem 1rem}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    pre code{white-space:pre}
  </style>

  <h3 class="mb-3">4.1.8 MOST (krok za krokem): Rozpočet</h3>
  <p class="lead">
    Z minikroků poskládáme textový „Rozpočet“: <b>příjem</b>, <b>výdaj</b>, <b>výpis</b>, <b>zůstatek</b>, <b>Undo</b>. 
    Vzorec je stejný jako u kalkulačky: <b>UI-data</b> v seznamu n-tic, <b>dispatcher</b> se <code>.get()</code>, <b>čisté funkce</b> a <b>main guard</b>.
  </p>

  <div class="accordion" id="acc-bridge-budget-mini">

    <!-- Krok 1: Data a vstupy -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm1h">
        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#bbm1" aria-expanded="true">
          1) Datové struktury + bezpečný vstup (int ≥ 0)
        </button>
      </h2>
      <div id="bbm1" class="accordion-collapse collapse show" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python"># --- data ---
# Záznam = n-tice (typ, popis, castka), kde typ je "prijem" nebo "vydaj"
zaznamy: list[tuple[str, str, int]] = []
undo_stack: list[tuple[str, tuple[str, str, int]]] = []  # zásobník pro Undo

# --- vstup ---
def nacti_cele_cislo_kladne(prompt="Zadejte částku (>= 0): ") -> int:
    while True:
        try:
            hodnota = int(input(prompt))
            if hodnota &lt; 0:
                print("Částka nesmí být záporná.")
                continue
            return hodnota
        except ValueError:
            print("Tohle není celé číslo.")</code></pre>
          <ul class="mb-2">
            <li><span class="mono">zaznamy</span> = náš „sešit“ rozpočtu (chronologicky).</li>
            <li><span class="mono">undo_stack</span> = zásobník posledních kroků pro „Zpět“.</li>
          </ul>
          <div class="tip">Mini-úkol: dovol i <span class="mono">float</span> částky (jen změň <span class="mono">int</span> → <span class="mono">float</span> a přepočítání).</div>
        </div>
      </div>
    </div>

    <!-- Krok 2: Čisté funkce logiky -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm2h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm2">
          2) Logika jako čisté funkce: přidání + zůstatek + výpis
        </button>
      </h2>
      <div id="bbm2" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python">def pridej_prijem(zaznamy: list, popis: str, castka: int) -> tuple[str, tuple]:
    zaznam = ("prijem", popis, castka)
    zaznamy.append(zaznam)
    return ("push", zaznam)  # info pro Undo

def pridej_vydaj(zaznamy: list, popis: str, castka: int) -> tuple[str, tuple]:
    zaznam = ("vydaj", popis, castka)
    zaznamy.append(zaznam)
    return ("push", zaznam)

def zustatek(zaznamy: list) -> int:
    prijmy = sum(c for t, _, c in zaznamy if t == "prijem")
    vydaje = sum(c for t, _, c in zaznamy if t == "vydaj")
    return prijmy - vydaje

def vypsat(zaznamy: list) -> None:
    if not zaznamy:
        print("Rozpočet je prázdný.")
        return
    print("=== Položky rozpočtu ===")
    for i, (t, p, c) in enumerate(zaznamy, start=1):
        znak = "+" if t == "prijem" else "-"
        print(f"{i}. {znak}{c}  {p}")</code></pre>
          <div class="ok">Čisté funkce = snadno testovatelné, UI je nebude „míchat“ s inputy.</div>
          <div class="tip">Mini-úkol: přidej <span class="mono">vycistit(zaznamy)</span> (vyprázdní seznam a vrátí třeba <span class="mono">("clear", None)</span> pro navazující „redo“ — to teď neřešíme).</div>
        </div>
      </div>
    </div>

    <!-- Krok 3: Akce (UI vrstva) + Undo -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm3h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm3">
          3) UI akce: ptají se uživatele, volají logiku, spravují Undo
        </button>
      </h2>
      <div id="bbm3" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python">def akce_prijem():
    popis = input("Popis příjmu: ").strip()
    castka = nacti_cele_cislo_kladne("Částka: ")
    op = pridej_prijem(zaznamy, popis, castka)
    undo_stack.append(op)
    print("Příjem přidán.")

def akce_vydaj():
    popis = input("Popis výdaje: ").strip()
    castka = nacti_cele_cislo_kladne("Částka: ")
    op = pridej_vydaj(zaznamy, popis, castka)
    undo_stack.append(op)
    print("Výdaj přidán.")

def akce_vypis():
    vypsat(zaznamy)

def akce_zustatek():
    print("Zůstatek:", zustatek(zaznamy))

def akce_undo():
    if not undo_stack:
        print("Není co vracet.")
        return
    typ, data = undo_stack.pop()
    if typ == "push":
        if zaznamy and zaznamy[-1] == data:
            zaznamy.pop()
            print("Poslední položka vrácena (Undo).")
        else:
            print("Nelze vrátit – stav se neshoduje.")</code></pre>
          <button class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#m-undo2">Jak Undo funguje (viz zásobník)?</button>
        </div>
      </div>
    </div>

    <!-- Krok 4: UI data (VOLBY) -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm4h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm4">
          4) UI-data: seznam n-tic „VOLBY“ + tisk menu
        </button>
      </h2>
      <div id="bbm4" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python"># (klíč, text do menu, funkce-akce)
VOLBY = [
    ("1", "Přidat příjem",          akce_prijem),
    ("2", "Přidat výdaj",           akce_vydaj),
    ("3", "Vypsat položky",         akce_vypis),
    ("4", "Zobrazit zůstatek",      akce_zustatek),
    ("5", "Vrátit poslední (Undo)", akce_undo),
    ("6", "Konec",                  None),
]

def vypis_menu(volby):
    print("=== Rozpočet – menu ===")
    for k, txt, _ in volby:
        print(f"{k}) {txt}")</code></pre>
          <div class="ok">Jeden zdroj pravdy – přidám řádek a vše se samo propíše.</div>
          <div class="tip">Mini-úkol: přidej volbu „7) Vyčistit rozpočet“ (vyprázdni <span class="mono">zaznamy</span> i <span class="mono">undo_stack</span>).</div>
        </div>
      </div>
    </div>

    <!-- Krok 5: Dispatcher + .get() -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm5h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm5">
          5) Dispatcher slovník + bezpečné <code>.get()</code>
        </button>
      </h2>
      <div id="bbm5" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python">DISPATCH = {k: (txt, fn) for k, txt, fn in VOLBY}

def rozpoctove_menu():
    while True:
        vypis_menu(VOLBY)
        volba = input("Zadejte možnost: ").strip()

        par = DISPATCH.get(volba)   # žádný KeyError při neplatné volbě
        if par is None:
            print("Neplatná volba, zkuste to znovu.")
            continue

        txt, fn = par
        if fn is None:
            print("Ukončuji Rozpočet.")
            break

        fn()</code></pre>
          <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#m-get">Proč použít <code>.get()</code> místo hranatých závorek?</button>
        </div>
      </div>
    </div>

    <!-- Krok 6: Hlavní menu + main guard -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm6h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm6">
          6) Hlavní menu a vstupní bod skriptu (main guard)
        </button>
      </h2>
      <div id="bbm6" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python">MAIN_VOLBY = [
    ("1", "Rozpočet", rozpoctove_menu),
    ("2", "Konec programu", None),
]
MAIN_DISPATCH = {k: (txt, fn) for k, txt, fn in MAIN_VOLBY}

def hlavni_menu():
    while True:
        print("=== Hlavní menu ===")
        for k, txt, _ in MAIN_VOLBY:
            print(f"{k}) {txt}")
        v = input("Zadejte možnost: ").strip()

        par = MAIN_DISPATCH.get(v)
        if par is None:
            print("Neplatná volba.")
            continue

        txt, fn = par
        if fn is None:
            print("Ukončuji program.")
            break

        fn()

if __name__ == "__main__":
    hlavni_menu()</code></pre>
          <div class="ok">Stejné schéma jako u kalkulačky – čisté a rozšiřitelné.</div>
        </div>
      </div>
    </div>

    <!-- Krok 7: Malé testy logiky (volitelné) -->
    <div class="accordion-item">
      <h2 class="accordion-header" id="bbm7h">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bbm7">
          7) (Volitelné) Rychlé ověření logiky bez UI
        </button>
      </h2>
      <div id="bbm7" class="accordion-collapse collapse" data-bs-parent="#acc-bridge-budget-mini">
        <div class="accordion-body">
<pre><code class="language-python"># Otestuj si rychle v interaktivní konzoli:
_test = []
pridej_prijem(_test, "stipendium", 1000)
pridej_vydaj(_test, "oběd", 150)
assert zustatek(_test) == 850</code></pre>
          <div class="tip">Mini-úkol: přidej alespoň jeden další test (např. dva výdaje, dvě různá pořadí).</div>
        </div>
      </div>
    </div>

  </div>

  <!-- Finální mini projekt: Rozpočet komplet -->
  <div class="card mt-4">
    <div class="card-body">
      <h5 class="card-title">✅ Rozpočet – plná verze (zkopíruj a spusť)</h5>
<pre><code class="language-python"># --- data ---
zaznamy: list[tuple[str, str, int]] = []
undo_stack: list[tuple[str, tuple[str, str, int]]] = []

# --- vstup ---
def nacti_cele_cislo_kladne(prompt="Zadejte částku (>= 0): ") -> int:
    while True:
        try:
            hodnota = int(input(prompt))
            if hodnota &lt; 0:
                print("Částka nesmí být záporná.")
                continue
            return hodnota
        except ValueError:
            print("Tohle není celé číslo.")

# --- logika ---
def pridej_prijem(zaznamy: list, popis: str, castka: int) -> tuple[str, tuple]:
    zaznam = ("prijem", popis, castka)
    zaznamy.append(zaznam)
    return ("push", zaznam)

def pridej_vydaj(zaznamy: list, popis: str, castka: int) -> tuple[str, tuple]:
    zaznam = ("vydaj", popis, castka)
    zaznamy.append(zaznam)
    return ("push", zaznam)

def zustatek(zaznamy: list) -> int:
    prijmy = sum(c for t, _, c in zaznamy if t == "prijem")
    vydaje = sum(c for t, _, c in zaznamy if t == "vydaj")
    return prijmy - vydaje

def vypsat(zaznamy: list) -> None:
    if not zaznamy:
        print("Rozpočet je prázdný.")
        return
    print("=== Položky rozpočtu ===")
    for i, (t, p, c) in enumerate(zaznamy, start=1):
        znak = "+" if t == "prijem" else "-"
        print(f"{i}. {znak}{c}  {p}")

# --- UI akce ---
def akce_prijem():
    popis = input("Popis příjmu: ").strip()
    castka = nacti_cele_cislo_kladne("Částka: ")
    op = pridej_prijem(zaznamy, popis, castka)
    undo_stack.append(op)
    print("Příjem přidán.")

def akce_vydaj():
    popis = input("Popis výdaje: ").strip()
    castka = nacti_cele_cislo_kladne("Částka: ")
    op = pridej_vydaj(zaznamy, popis, castka)
    undo_stack.append(op)
    print("Výdaj přidán.")

def akce_vypis():
    vypsat(zaznamy)

def akce_zustatek():
    print("Zůstatek:", zustatek(zaznamy))

def akce_undo():
    if not undo_stack:
        print("Není co vracet.")
        return
    typ, data = undo_stack.pop()
    if typ == "push":
        if zaznamy and zaznamy[-1] == data:
            zaznamy.pop()
            print("Poslední položka vrácena (Undo).")
        else:
            print("Nelze vrátit – stav se neshoduje.")

# --- UI data + dispatcher ---
VOLBY = [
    ("1", "Přidat příjem",          akce_prijem),
    ("2", "Přidat výdaj",           akce_vydaj),
    ("3", "Vypsat položky",         akce_vypis),
    ("4", "Zobrazit zůstatek",      akce_zustatek),
    ("5", "Vrátit poslední (Undo)", akce_undo),
    ("6", "Konec",                  None),
]
DISPATCH = {k: (txt, fn) for k, txt, fn in VOLBY}

def vypis_menu(volby):
    print("=== Rozpočet – menu ===")
    for k, txt, _ in volby:
        print(f"{k}) {txt}")

def rozpoctove_menu():
    while True:
        vypis_menu(VOLBY)
        volba = input("Zadejte možnost: ").strip()
        par = DISPATCH.get(volba)
        if par is None:
            print("Neplatná volba, zkuste to znovu.")
            continue
        txt, fn = par
        if fn is None:
            print("Ukončuji Rozpočet.")
            break
        fn()

# --- hlavní menu + main guard ---
MAIN_VOLBY = [
    ("1", "Rozpočet", rozpoctove_menu),
    ("2", "Konec programu", None),
]
MAIN_DISPATCH = {k: (txt, fn) for k, txt, fn in MAIN_VOLBY}

def hlavni_menu():
    while True:
        print("=== Hlavní menu ===")
        for k, txt, _ in MAIN_VOLBY:
            print(f"{k}) {txt}")
        v = input("Zadejte možnost: ").strip()
        par = MAIN_DISPATCH.get(v)
        if par is None:
            print("Neplatná volba.")
            continue
        txt, fn = par
        if fn is None:
            print("Ukončuji program.")
            break
        fn()

if __name__ == "__main__":
    hlavni_menu()</code></pre>

      <div class="tip">
        Mini-úkoly: 
        ① Přidej „7) Vyčistit rozpočet“. 
        ② Přidej „Najít položky podle textu“ (case-insensitive filtr <span class="mono">popis</span>u). 
        ③ Uprav vstup na <span class="mono">float</span> (částky s desetinnou tečkou).
      </div>
    </div>
  </div>
</section>

<!-- ===================== MODÁLY – vysvětlivky ===================== -->
<div class="modal fade" id="m-undo2" tabindex="-1" aria-labelledby="m-undo2Label" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered"><div class="modal-content">
    <div class="modal-header"><h5 id="m-undo2Label" class="modal-title">Undo zásobník (stack): push → pop</h5>
      <button class="btn-close" data-bs-dismiss="modal"></button></div>
    <div class="modal-body">
      Každé přidání uložíme do <code>undo_stack</code> jako <code>("push", data)</code>. „Vrátit poslední“ udělá <code>pop()</code> a 
      pokud poslední položka rozpočtu odpovídá, odstraní ji. Nejjednodušší a spolehlivý „Zpět“.
    </div>
  </div></div>
</div>

<div class="modal fade" id="m-get" tabindex="-1" aria-labelledby="m-getLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered"><div class="modal-content">
    <div class="modal-header"><h5 id="m-getLabel" class="modal-title">Proč <code>.get()</code> u slovníku?</h5>
      <button class="btn-close" data-bs-dismiss="modal"></button></div>
    <div class="modal-body">
      <code>slovnik.get(klic)</code> vrátí <em>None</em>, když klíč není – program nespadne (<em>KeyError</em>), jen obsloužíš „Neplatná volba“.
    </div>
  </div></div>
</div>
